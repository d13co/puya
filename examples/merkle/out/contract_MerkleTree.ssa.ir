contract examples.merkle.contract.MerkleTree:
    program approval:
        subroutine examples.merkle.contract.MerkleTree.approval_program() -> uint64:
            block@0: // L29
                let app_id%0#0: uint64 = (txn ApplicationID)
                goto app_id%0#0 ? block@2 : block@1
            block@1: // on_create_L30
                examples.merkle.contract.MerkleTree.__init__()
                goto block@2
            block@2: // entrypoint_L30
                let tmp%1#0: uint64 = (txn NumAppArgs)
                goto tmp%1#0 ? block@3 : block@10
            block@3: // abi_routing_L29
                let tmp%2#0: bytes = (txna ApplicationArgs 0)
                switch tmp%2#0 {method "create()void" => block@4, method "delete_application()void" => block@5, method "append_leaf(byte[],byte[33][3])void" => block@6, method "update_leaf(byte[],byte[],byte[33][3])void" => block@7, * => block@8}
            block@4: // create_route_L43
                let tmp%3#0: uint64 = (txn OnCompletion)
                let tmp%4#0: uint64 = (== tmp%3#0 NoOp)
                (assert tmp%4#0) // OnCompletion is NoOp
                let tmp%5#0: uint64 = (txn ApplicationID)
                (assert tmp%5#0) // is not creating
                examples.merkle.contract.MerkleTree.create()
                return 1u
            block@5: // delete_application_route_L61
                let tmp%6#0: uint64 = (txn OnCompletion)
                let tmp%7#0: uint64 = (== tmp%6#0 NoOp)
                (assert tmp%7#0) // OnCompletion is NoOp
                let tmp%8#0: uint64 = (txn ApplicationID)
                (assert tmp%8#0) // is not creating
                examples.merkle.contract.MerkleTree.delete_application()
                return 1u
            block@6: // append_leaf_route_L69
                let tmp%9#0: uint64 = (txn OnCompletion)
                let tmp%10#0: uint64 = (== tmp%9#0 NoOp)
                (assert tmp%10#0) // OnCompletion is NoOp
                let tmp%11#0: uint64 = (txn ApplicationID)
                (assert tmp%11#0) // is not creating
                let tmp%12#0: bytes = (txna ApplicationArgs 1)
                let tmp%13#0: bytes = ((extract 2 0) tmp%12#0)
                let tmp%14#0: bytes = (txna ApplicationArgs 2)
                examples.merkle.contract.MerkleTree.append_leaf(tmp%13#0, tmp%14#0)
                return 1u
            block@7: // update_leaf_route_L81
                let tmp%15#0: uint64 = (txn OnCompletion)
                let tmp%16#0: uint64 = (== tmp%15#0 NoOp)
                (assert tmp%16#0) // OnCompletion is NoOp
                let tmp%17#0: uint64 = (txn ApplicationID)
                (assert tmp%17#0) // is not creating
                let tmp%18#0: bytes = (txna ApplicationArgs 1)
                let tmp%19#0: bytes = ((extract 2 0) tmp%18#0)
                let tmp%20#0: bytes = (txna ApplicationArgs 2)
                let tmp%21#0: bytes = ((extract 2 0) tmp%20#0)
                let tmp%22#0: bytes = (txna ApplicationArgs 3)
                examples.merkle.contract.MerkleTree.update_leaf(tmp%19#0, tmp%21#0, tmp%22#0)
                return 1u
            block@8: // switch_case_default_L29
                goto block@9
            block@9: // switch_case_next_L29
                goto block@13
            block@10: // bare_routing_L29
                let tmp%23#0: uint64 = (txn OnCompletion)
                switch tmp%23#0 {0u => block@11, * => block@12}
            block@11: // create_L29
                let tmp%24#0: uint64 = (txn ApplicationID)
                let tmp%25#0: uint64 = (! tmp%24#0)
                (assert tmp%25#0) // is creating
                return 1u
            block@12: // reject_bare_on_completion_L29
                fail // reject transaction
            block@13: // after_if_else_L29
                fail // reject transaction
        
        subroutine examples.merkle.contract.MerkleTree.create() -> void:
            block@0: // L43
                let new_state_value%0#0: bytes = examples.merkle.contract.MerkleTree.calc_init_root()
                (app_global_put "root" new_state_value%0#0)
                return 
        
        subroutine examples.merkle.contract.MerkleTree.calc_init_root() -> bytes:
            block@0: // L34
                let result#0: bytes = 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
                (assert 1u) // Step cannot be zero
                let range_item%0#0: uint64 = 0u
                goto block@1
            block@1: // for_header_L37
                let range_item%0#1: uint64 = φ(range_item%0#0 <- block@0, range_item%0#3 <- block@4)
                let result#3: bytes = φ(result#0 <- block@0, result#2 <- block@4)
                let continue_looping%1#0: uint64 = (< range_item%0#1 3u)
                goto continue_looping%1#0 ? block@2 : block@5
            block@2: // for_body_L37
                let _i#0: uint64 = range_item%0#1
                let tmp%2#0: bytes = (concat result#3 result#3)
                let result#2: bytes = (sha256 tmp%2#0)
                goto block@3
            block@3: // for_footer_L37
                goto block@4
            block@4: // for_increment_L37
                let range_item%0#3: uint64 = (+ range_item%0#1 1u)
                goto block@1
            block@5: // after_for_L37
                let y#0: bytes = result#3
                let awst_tmp%3#0: bytes = result#3
                let tmp%4#0: uint64 = (len awst_tmp%3#0)
                let val_as_bytes%5#0: bytes = (itob tmp%4#0)
                let tmp%6#0: bytes = ((extract 6 2) val_as_bytes%5#0)
                let x#0: bytes = (concat tmp%6#0 awst_tmp%3#0)
                let awst_tmp%9#0: bytes = result#3
                let tmp%10#0: uint64 = (len awst_tmp%9#0)
                let tmp%11#0: uint64 = (== 32u tmp%10#0)
                let (maybe_value%7#0: bytes, maybe_value_did_exist%8#0: uint64) = (awst_tmp%9#0, tmp%11#0)
                (assert maybe_value_did_exist%8#0) // Argument must have a length of 32 bytes
                return maybe_value%7#0
        
        subroutine examples.merkle.contract.MerkleTree.delete_application() -> void:
            block@0: // L61
                let tmp%0#0: bytes = (txn Sender)
                let (maybe_value%1#0: bytes, maybe_value_did_exist%2#0: uint64) = ((app_params_get AppCreator) 0u)
                (assert maybe_value_did_exist%2#0) // application exists
                let tmp%3#0: uint64 = (== tmp%0#0 maybe_value%1#0)
                (assert tmp%3#0)
                return 
        
        subroutine examples.merkle.contract.MerkleTree.append_leaf(data: bytes, path: bytes) -> void:
            block@0: // L69
                let tmp%0#0: uint64 = (len data#0)
                (assert tmp%0#0)
                let (app_global_get_ex_value%1#0: bytes, app_global_get_ex_did_exist%2#0: uint64) = (app_global_get_ex 0u "root")
                (assert app_global_get_ex_did_exist%2#0) // check value exists
                let awst_tmp%5#0: bytes = 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
                let tmp%6#0: uint64 = (len awst_tmp%5#0)
                let tmp%7#0: uint64 = (== 32u tmp%6#0)
                let (maybe_value%3#0: bytes, maybe_value_did_exist%4#0: uint64) = (awst_tmp%5#0, tmp%7#0)
                (assert maybe_value_did_exist%4#0) // Argument must have a length of 32 bytes
                let tmp%8#0: bytes = examples.merkle.contract.MerkleTree.calc_root(maybe_value%3#0, path#0)
                let tmp%9#0: uint64 = (== app_global_get_ex_value%1#0 tmp%8#0)
                (assert tmp%9#0)
                let awst_tmp%12#0: bytes = (sha256 data#0)
                let tmp%13#0: uint64 = (len awst_tmp%12#0)
                let tmp%14#0: uint64 = (== 32u tmp%13#0)
                let (maybe_value%10#0: bytes, maybe_value_did_exist%11#0: uint64) = (awst_tmp%12#0, tmp%14#0)
                (assert maybe_value_did_exist%11#0) // Argument must have a length of 32 bytes
                let new_state_value%15#0: bytes = examples.merkle.contract.MerkleTree.calc_root(maybe_value%10#0, path#0)
                (app_global_put "root" new_state_value%15#0)
                let (app_global_get_ex_value%16#0: uint64, app_global_get_ex_did_exist%17#0: uint64) = (app_global_get_ex 0u "size")
                (assert app_global_get_ex_did_exist%17#0) // check value exists
                let new_state_value%18#0: uint64 = (+ app_global_get_ex_value%16#0 1u)
                (app_global_put "size" new_state_value%18#0)
                return 
        
        subroutine examples.merkle.contract.MerkleTree.calc_root(leaf: bytes, path: bytes) -> bytes:
            block@0: // L51
                let result#0: bytes = leaf#0
                let item_index_internal%0#0: uint64 = 0u
                let reverse_index_internal%1#0: uint64 = 3u
                goto block@1
            block@1: // for_header_L54
                let item_index_internal%0#1: uint64 = φ(item_index_internal%0#0 <- block@0, item_index_internal%0#3 <- block@6)
                let result#1: bytes = φ(result#0 <- block@0, result#4 <- block@6)
                let continue_looping%2#0: uint64 = (< item_index_internal%0#1 3u)
                goto continue_looping%2#0 ? block@2 : block@7
            block@2: // for_body_L54
                let item_index%3#0: uint64 = (* item_index_internal%0#1 33u)
                let branch#0: bytes = (extract3 path#0 item_index%3#0 33u)
                let tmp%4#0: uint64 = examples.merkle.contract.MerkleTree.is_right_sibling(branch#0)
                goto tmp%4#0 ? block@3 : block@4
            block@3: // if_body_L55
                let tmp%5#0: bytes = ((extract 1 32) branch#0)
                let tmp%6#0: bytes = (concat result#1 tmp%5#0)
                let result#2: bytes = (sha256 tmp%6#0)
                goto block@5
            block@4: // else_body_L55
                let tmp%7#0: bytes = ((extract 1 32) branch#0)
                let tmp%8#0: bytes = (concat tmp%7#0 result#1)
                let result#3: bytes = (sha256 tmp%8#0)
                goto block@5
            block@5: // after_if_else_L55
                let result#4: bytes = φ(result#2 <- block@3, result#3 <- block@4)
                goto block@6
            block@6: // for_footer_L54
                let item_index_internal%0#3: uint64 = (+ item_index_internal%0#1 1u)
                goto block@1
            block@7: // after_for_L54
                let awst_tmp%11#0: bytes = result#1
                let tmp%12#0: uint64 = (len awst_tmp%11#0)
                let tmp%13#0: uint64 = (== 32u tmp%12#0)
                let (maybe_value%9#0: bytes, maybe_value_did_exist%10#0: uint64) = (awst_tmp%11#0, tmp%13#0)
                (assert maybe_value_did_exist%10#0) // Argument must have a length of 32 bytes
                return maybe_value%9#0
        
        subroutine examples.merkle.contract.MerkleTree.is_right_sibling(elem: bytes) -> uint64:
            block@0: // L47
                let item_index%0#0: uint64 = (* 0u 1u)
                let tmp%1#0: bytes = (extract3 elem#0 item_index%0#0 1u)
                let tmp%2#0: bytes = (itob 170u)
                let tmp%3#0: bytes = ((extract 7 1) tmp%2#0)
                let tmp%4#0: uint64 = (== tmp%1#0 tmp%3#0)
                return tmp%4#0
        
        subroutine examples.merkle.contract.MerkleTree.update_leaf(old_data: bytes, new_data: bytes, path: bytes) -> void:
            block@0: // L81
                let tmp%0#0: uint64 = (len new_data#0)
                (assert tmp%0#0)
                let (app_global_get_ex_value%1#0: bytes, app_global_get_ex_did_exist%2#0: uint64) = (app_global_get_ex 0u "root")
                (assert app_global_get_ex_did_exist%2#0) // check value exists
                let awst_tmp%5#0: bytes = old_data#0
                let tmp%6#0: uint64 = (len awst_tmp%5#0)
                let tmp%7#0: uint64 = (== 32u tmp%6#0)
                let (maybe_value%3#0: bytes, maybe_value_did_exist%4#0: uint64) = (awst_tmp%5#0, tmp%7#0)
                (assert maybe_value_did_exist%4#0) // Argument must have a length of 32 bytes
                let tmp%8#0: bytes = examples.merkle.contract.MerkleTree.calc_root(maybe_value%3#0, path#0)
                let tmp%9#0: uint64 = (== app_global_get_ex_value%1#0 tmp%8#0)
                (assert tmp%9#0)
                let awst_tmp%12#0: bytes = (sha256 new_data#0)
                let tmp%13#0: uint64 = (len awst_tmp%12#0)
                let tmp%14#0: uint64 = (== 32u tmp%13#0)
                let (maybe_value%10#0: bytes, maybe_value_did_exist%11#0: uint64) = (awst_tmp%12#0, tmp%14#0)
                (assert maybe_value_did_exist%11#0) // Argument must have a length of 32 bytes
                let new_state_value%15#0: bytes = examples.merkle.contract.MerkleTree.calc_root(maybe_value%10#0, path#0)
                (app_global_put "root" new_state_value%15#0)
                return 
        
        subroutine examples.merkle.contract.MerkleTree.__init__() -> void:
            block@0: // L30
                return 
    
    program clear-state:
        subroutine examples.merkle.contract.MerkleTree.clear_state_program() -> uint64:
            block@0: // L29
                return 1u